
devBoardSPI.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003c4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00802000  000003c4  00000458  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000019  00802006  00802006  0000045e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000045e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000490  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000070  00000000  00000000  000004d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000030a4  00000000  00000000  00000540  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002424  00000000  00000000  000035e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000829  00000000  00000000  00005a08  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000f0  00000000  00000000  00006234  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001d9a  00000000  00000000  00006324  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000061f  00000000  00000000  000080be  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000050  00000000  00000000  000086dd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 bc 00 	jmp	0x178	; 0x178 <__ctors_end>
   4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
   8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
   c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  10:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  14:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  18:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  1c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  20:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  24:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  28:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  2c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  30:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  34:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  38:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  3c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  40:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  44:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  48:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  4c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  50:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  54:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  58:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  5c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  60:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  64:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  68:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  6c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  70:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  74:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  78:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  7c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  80:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  84:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  88:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  8c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  90:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  94:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  98:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  9c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  a0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  a4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  a8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  ac:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  b0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  b4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  b8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  bc:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  c0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  c4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  c8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  cc:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  d0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  d4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  d8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  dc:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  e0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  e4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  e8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  ec:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  f0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  f4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  f8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
  fc:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 100:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 104:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 108:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 10c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 110:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 114:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 118:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 11c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 120:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 124:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 128:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 12c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 130:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 134:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 138:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 13c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 140:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 144:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 148:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 14c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 150:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 154:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 158:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 15c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 160:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 164:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 168:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 16c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 170:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
 174:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>

00000178 <__ctors_end>:
 178:	11 24       	eor	r1, r1
 17a:	1f be       	out	0x3f, r1	; 63
 17c:	cf ef       	ldi	r28, 0xFF	; 255
 17e:	cd bf       	out	0x3d, r28	; 61
 180:	d7 e2       	ldi	r29, 0x27	; 39
 182:	de bf       	out	0x3e, r29	; 62

00000184 <__do_copy_data>:
 184:	10 e2       	ldi	r17, 0x20	; 32
 186:	a0 e0       	ldi	r26, 0x00	; 0
 188:	b0 e2       	ldi	r27, 0x20	; 32
 18a:	e4 ec       	ldi	r30, 0xC4	; 196
 18c:	f3 e0       	ldi	r31, 0x03	; 3
 18e:	02 c0       	rjmp	.+4      	; 0x194 <__do_copy_data+0x10>
 190:	05 90       	lpm	r0, Z+
 192:	0d 92       	st	X+, r0
 194:	a6 30       	cpi	r26, 0x06	; 6
 196:	b1 07       	cpc	r27, r17
 198:	d9 f7       	brne	.-10     	; 0x190 <__do_copy_data+0xc>

0000019a <__do_clear_bss>:
 19a:	20 e2       	ldi	r18, 0x20	; 32
 19c:	a6 e0       	ldi	r26, 0x06	; 6
 19e:	b0 e2       	ldi	r27, 0x20	; 32
 1a0:	01 c0       	rjmp	.+2      	; 0x1a4 <.do_clear_bss_start>

000001a2 <.do_clear_bss_loop>:
 1a2:	1d 92       	st	X+, r1

000001a4 <.do_clear_bss_start>:
 1a4:	af 31       	cpi	r26, 0x1F	; 31
 1a6:	b2 07       	cpc	r27, r18
 1a8:	e1 f7       	brne	.-8      	; 0x1a2 <.do_clear_bss_loop>
 1aa:	0e 94 85 01 	call	0x30a	; 0x30a <main>
 1ae:	0c 94 e0 01 	jmp	0x3c0	; 0x3c0 <_exit>

000001b2 <__bad_interrupt>:
 1b2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001b6 <SPI_MasterInit>:
	data = spi->dataPacket->transmitData[0];
	spi->module->DATA = data;

	/* Successs */
	return (SPI_OK);
}
 1b6:	af 92       	push	r10
 1b8:	cf 92       	push	r12
 1ba:	ef 92       	push	r14
 1bc:	0f 93       	push	r16
 1be:	fc 01       	movw	r30, r24
 1c0:	60 83       	st	Z, r22
 1c2:	71 83       	std	Z+1, r23	; 0x01
 1c4:	42 83       	std	Z+2, r20	; 0x02
 1c6:	53 83       	std	Z+3, r21	; 0x03
 1c8:	14 82       	std	Z+4, r1	; 0x04
 1ca:	c1 10       	cpse	r12, r1
 1cc:	02 c0       	rjmp	.+4      	; 0x1d2 <SPI_MasterInit+0x1c>
 1ce:	80 e0       	ldi	r24, 0x00	; 0
 1d0:	01 c0       	rjmp	.+2      	; 0x1d4 <SPI_MasterInit+0x1e>
 1d2:	80 e8       	ldi	r24, 0x80	; 128
 1d4:	9a 2d       	mov	r25, r10
 1d6:	90 64       	ori	r25, 0x40	; 64
 1d8:	a9 2e       	mov	r10, r25
 1da:	a8 2a       	or	r10, r24
 1dc:	21 11       	cpse	r18, r1
 1de:	02 c0       	rjmp	.+4      	; 0x1e4 <SPI_MasterInit+0x2e>
 1e0:	80 e0       	ldi	r24, 0x00	; 0
 1e2:	01 c0       	rjmp	.+2      	; 0x1e6 <SPI_MasterInit+0x30>
 1e4:	80 e2       	ldi	r24, 0x20	; 32
 1e6:	a8 2a       	or	r10, r24
 1e8:	00 61       	ori	r16, 0x10	; 16
 1ea:	0a 29       	or	r16, r10
 1ec:	db 01       	movw	r26, r22
 1ee:	0c 93       	st	X, r16
 1f0:	a0 81       	ld	r26, Z
 1f2:	b1 81       	ldd	r27, Z+1	; 0x01
 1f4:	11 96       	adiw	r26, 0x01	; 1
 1f6:	ec 92       	st	X, r14
 1f8:	15 82       	std	Z+5, r1	; 0x05
 1fa:	16 82       	std	Z+6, r1	; 0x06
 1fc:	02 80       	ldd	r0, Z+2	; 0x02
 1fe:	f3 81       	ldd	r31, Z+3	; 0x03
 200:	e0 2d       	mov	r30, r0
 202:	80 ea       	ldi	r24, 0xA0	; 160
 204:	81 83       	std	Z+1, r24	; 0x01
 206:	0f 91       	pop	r16
 208:	ef 90       	pop	r14
 20a:	cf 90       	pop	r12
 20c:	af 90       	pop	r10
 20e:	08 95       	ret

00000210 <SPI_MasterCreateDataPacket>:
 210:	ef 92       	push	r14
 212:	0f 93       	push	r16
 214:	1f 93       	push	r17
 216:	fc 01       	movw	r30, r24
 218:	00 83       	st	Z, r16
 21a:	11 83       	std	Z+1, r17	; 0x01
 21c:	e2 82       	std	Z+2, r14	; 0x02
 21e:	63 83       	std	Z+3, r22	; 0x03
 220:	74 83       	std	Z+4, r23	; 0x04
 222:	45 83       	std	Z+5, r20	; 0x05
 224:	56 83       	std	Z+6, r21	; 0x06
 226:	27 83       	std	Z+7, r18	; 0x07
 228:	10 86       	std	Z+8, r1	; 0x08
 22a:	11 86       	std	Z+9, r1	; 0x09
 22c:	1f 91       	pop	r17
 22e:	0f 91       	pop	r16
 230:	ef 90       	pop	r14
 232:	08 95       	ret

00000234 <SPI_MasterTransceiveByte>:
 *  \return           Data received from slave.
 */
uint8_t SPI_MasterTransceiveByte(SPI_Master_t *spi, uint8_t TXdata)
{
	/* Send pattern. */
	spi->module->DATA = TXdata;
 234:	dc 01       	movw	r26, r24
 236:	ed 91       	ld	r30, X+
 238:	fc 91       	ld	r31, X
 23a:	11 97       	sbiw	r26, 0x01	; 1
 23c:	63 83       	std	Z+3, r22	; 0x03

	/* Wait for transmission complete. */
	while(!(spi->module->STATUS & SPI_IF_bm)) {
 23e:	ed 91       	ld	r30, X+
 240:	fc 91       	ld	r31, X
 242:	82 81       	ldd	r24, Z+2	; 0x02
 244:	88 23       	and	r24, r24
 246:	ec f7       	brge	.-6      	; 0x242 <SPI_MasterTransceiveByte+0xe>

	}
	/* Read received data. */
	uint8_t result = spi->module->DATA;
 248:	83 81       	ldd	r24, Z+3	; 0x03

	return(result);
}
 24a:	08 95       	ret

0000024c <SPI_MasterTransceivePacket>:
 *  \retval true	   Success
 *  \retval false	   Failure
 */
bool SPI_MasterTransceivePacket(SPI_Master_t *spi,
                                SPI_DataPacket_t *dataPacket)
{
 24c:	cf 93       	push	r28
 24e:	df 93       	push	r29
 250:	dc 01       	movw	r26, r24
 252:	fb 01       	movw	r30, r22
	/* Check if data packet has been created. */
	if(dataPacket == NULL) {
 254:	30 97       	sbiw	r30, 0x00	; 0
 256:	09 f4       	brne	.+2      	; 0x25a <SPI_MasterTransceivePacket+0xe>
 258:	4e c0       	rjmp	.+156    	; 0x2f6 <SPI_MasterTransceivePacket+0xaa>
		return false;
	}

	/* Assign datapacket to SPI module. */
	spi->dataPacket = dataPacket;
 25a:	15 96       	adiw	r26, 0x05	; 5
 25c:	6d 93       	st	X+, r22
 25e:	7c 93       	st	X, r23
 260:	16 97       	sbiw	r26, 0x06	; 6

	uint8_t ssPinMask = spi->dataPacket->ssPinMask;
 262:	72 81       	ldd	r23, Z+2	; 0x02

	/* If SS signal to slave(s). */
	if (spi->dataPacket->ssPort != NULL) {
 264:	c0 81       	ld	r28, Z
 266:	d1 81       	ldd	r29, Z+1	; 0x01
 268:	20 97       	sbiw	r28, 0x00	; 0
 26a:	09 f4       	brne	.+2      	; 0x26e <SPI_MasterTransceivePacket+0x22>
 26c:	46 c0       	rjmp	.+140    	; 0x2fa <SPI_MasterTransceivePacket+0xae>
		/* SS to slave(s) low. */
		SPI_MasterSSLow(spi->dataPacket->ssPort, ssPinMask);
 26e:	7e 83       	std	Y+6, r23	; 0x06
	}

	/* Transceive bytes. */
	uint8_t bytesTransceived = 0;
	uint8_t bytesToTransceive = dataPacket->bytesToTransceive;
 270:	67 81       	ldd	r22, Z+7	; 0x07
	while (bytesTransceived < bytesToTransceive) {
 272:	66 23       	and	r22, r22
 274:	49 f1       	breq	.+82     	; 0x2c8 <SPI_MasterTransceivePacket+0x7c>
 *  \retval true	   Success
 *  \retval false	   Failure
 */
bool SPI_MasterTransceivePacket(SPI_Master_t *spi,
                                SPI_DataPacket_t *dataPacket)
{
 276:	20 e0       	ldi	r18, 0x00	; 0
 278:	30 e0       	ldi	r19, 0x00	; 0
 27a:	80 e0       	ldi	r24, 0x00	; 0
	uint8_t bytesTransceived = 0;
	uint8_t bytesToTransceive = dataPacket->bytesToTransceive;
	while (bytesTransceived < bytesToTransceive) {

		/* Send pattern. */
		uint8_t data = spi->dataPacket->transmitData[bytesTransceived];
 27c:	a9 01       	movw	r20, r18
 27e:	15 96       	adiw	r26, 0x05	; 5
 280:	ed 91       	ld	r30, X+
 282:	fc 91       	ld	r31, X
 284:	16 97       	sbiw	r26, 0x06	; 6
 286:	03 80       	ldd	r0, Z+3	; 0x03
 288:	f4 81       	ldd	r31, Z+4	; 0x04
 28a:	e0 2d       	mov	r30, r0
 28c:	e2 0f       	add	r30, r18
 28e:	f3 1f       	adc	r31, r19
 290:	90 81       	ld	r25, Z
		spi->module->DATA = data;
 292:	ed 91       	ld	r30, X+
 294:	fc 91       	ld	r31, X
 296:	11 97       	sbiw	r26, 0x01	; 1
 298:	93 83       	std	Z+3, r25	; 0x03

		/* Wait for transmission complete. */
		while(!(spi->module->STATUS & SPI_IF_bm)) {
 29a:	ed 91       	ld	r30, X+
 29c:	fc 91       	ld	r31, X
 29e:	11 97       	sbiw	r26, 0x01	; 1
 2a0:	92 81       	ldd	r25, Z+2	; 0x02
 2a2:	99 23       	and	r25, r25
 2a4:	ec f7       	brge	.-6      	; 0x2a0 <SPI_MasterTransceivePacket+0x54>

		}
		/* Read received data. */
		data = spi->module->DATA;
 2a6:	93 81       	ldd	r25, Z+3	; 0x03
		spi->dataPacket->receiveData[bytesTransceived] = data;
 2a8:	15 96       	adiw	r26, 0x05	; 5
 2aa:	ed 91       	ld	r30, X+
 2ac:	fc 91       	ld	r31, X
 2ae:	16 97       	sbiw	r26, 0x06	; 6
 2b0:	05 80       	ldd	r0, Z+5	; 0x05
 2b2:	f6 81       	ldd	r31, Z+6	; 0x06
 2b4:	e0 2d       	mov	r30, r0
 2b6:	e4 0f       	add	r30, r20
 2b8:	f5 1f       	adc	r31, r21
 2ba:	90 83       	st	Z, r25

		bytesTransceived++;
 2bc:	8f 5f       	subi	r24, 0xFF	; 255
 2be:	2f 5f       	subi	r18, 0xFF	; 255
 2c0:	3f 4f       	sbci	r19, 0xFF	; 255
	}

	/* Transceive bytes. */
	uint8_t bytesTransceived = 0;
	uint8_t bytesToTransceive = dataPacket->bytesToTransceive;
	while (bytesTransceived < bytesToTransceive) {
 2c2:	86 17       	cp	r24, r22
 2c4:	d8 f2       	brcs	.-74     	; 0x27c <SPI_MasterTransceivePacket+0x30>
 2c6:	01 c0       	rjmp	.+2      	; 0x2ca <SPI_MasterTransceivePacket+0x7e>
		/* SS to slave(s) low. */
		SPI_MasterSSLow(spi->dataPacket->ssPort, ssPinMask);
	}

	/* Transceive bytes. */
	uint8_t bytesTransceived = 0;
 2c8:	80 e0       	ldi	r24, 0x00	; 0

		bytesTransceived++;
	}

	/* If SS signal to slave(s). */
	if (spi->dataPacket->ssPort != NULL) {
 2ca:	15 96       	adiw	r26, 0x05	; 5
 2cc:	ed 91       	ld	r30, X+
 2ce:	fc 91       	ld	r31, X
 2d0:	16 97       	sbiw	r26, 0x06	; 6
 2d2:	01 90       	ld	r0, Z+
 2d4:	f0 81       	ld	r31, Z
 2d6:	e0 2d       	mov	r30, r0
 2d8:	30 97       	sbiw	r30, 0x00	; 0
 2da:	09 f0       	breq	.+2      	; 0x2de <SPI_MasterTransceivePacket+0x92>
		/* Release SS to slave(s). */
		SPI_MasterSSHigh(spi->dataPacket->ssPort, ssPinMask);
 2dc:	75 83       	std	Z+5, r23	; 0x05
	}

	/* Set variables to indicate that transmission is complete. */
	spi->dataPacket->bytesTransceived = bytesTransceived;
 2de:	15 96       	adiw	r26, 0x05	; 5
 2e0:	ed 91       	ld	r30, X+
 2e2:	fc 91       	ld	r31, X
 2e4:	16 97       	sbiw	r26, 0x06	; 6
 2e6:	80 87       	std	Z+8, r24	; 0x08
	spi->dataPacket->complete = true;
 2e8:	15 96       	adiw	r26, 0x05	; 5
 2ea:	ed 91       	ld	r30, X+
 2ec:	fc 91       	ld	r31, X
 2ee:	16 97       	sbiw	r26, 0x06	; 6
 2f0:	81 e0       	ldi	r24, 0x01	; 1
 2f2:	81 87       	std	Z+9, r24	; 0x09

	/* Report success. */
	return true;
 2f4:	07 c0       	rjmp	.+14     	; 0x304 <SPI_MasterTransceivePacket+0xb8>
bool SPI_MasterTransceivePacket(SPI_Master_t *spi,
                                SPI_DataPacket_t *dataPacket)
{
	/* Check if data packet has been created. */
	if(dataPacket == NULL) {
		return false;
 2f6:	80 e0       	ldi	r24, 0x00	; 0
 2f8:	05 c0       	rjmp	.+10     	; 0x304 <SPI_MasterTransceivePacket+0xb8>
		SPI_MasterSSLow(spi->dataPacket->ssPort, ssPinMask);
	}

	/* Transceive bytes. */
	uint8_t bytesTransceived = 0;
	uint8_t bytesToTransceive = dataPacket->bytesToTransceive;
 2fa:	67 81       	ldd	r22, Z+7	; 0x07
	while (bytesTransceived < bytesToTransceive) {
 2fc:	61 11       	cpse	r22, r1
 2fe:	bb cf       	rjmp	.-138    	; 0x276 <SPI_MasterTransceivePacket+0x2a>
		/* SS to slave(s) low. */
		SPI_MasterSSLow(spi->dataPacket->ssPort, ssPinMask);
	}

	/* Transceive bytes. */
	uint8_t bytesTransceived = 0;
 300:	80 e0       	ldi	r24, 0x00	; 0
 302:	ed cf       	rjmp	.-38     	; 0x2de <SPI_MasterTransceivePacket+0x92>
	spi->dataPacket->bytesTransceived = bytesTransceived;
	spi->dataPacket->complete = true;

	/* Report success. */
	return true;
}
 304:	df 91       	pop	r29
 306:	cf 91       	pop	r28
 308:	08 95       	ret

0000030a <main>:
 *  infinite for-loop if the test was successful.
 */
int main(void)
{
	/* Init SS pin as output with wired AND and pull-up. */
	PORTD.DIRSET = PIN4_bm;
 30a:	c0 e6       	ldi	r28, 0x60	; 96
 30c:	d6 e0       	ldi	r29, 0x06	; 6
 30e:	10 e1       	ldi	r17, 0x10	; 16
 310:	19 83       	std	Y+1, r17	; 0x01
	PORTD.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
 312:	88 e3       	ldi	r24, 0x38	; 56
 314:	8c 8b       	std	Y+20, r24	; 0x14

	/* Set SS output to high. (No slave addressed). */
	PORTD.OUTSET = PIN4_bm;
 316:	1d 83       	std	Y+5, r17	; 0x05

	/* Instantiate pointer to ssPort. */
	PORT_t *ssPort = &PORTD;

	/* Initialize SPI master on port D. */
	SPI_MasterInit(&spiMasterD,
 318:	a1 2c       	mov	r10, r1
 31a:	c1 2c       	mov	r12, r1
 31c:	e1 2c       	mov	r14, r1
 31e:	00 e0       	ldi	r16, 0x00	; 0
 320:	20 e0       	ldi	r18, 0x00	; 0
 322:	40 e6       	ldi	r20, 0x60	; 96
 324:	56 e0       	ldi	r21, 0x06	; 6
 326:	60 ec       	ldi	r22, 0xC0	; 192
 328:	79 e0       	ldi	r23, 0x09	; 9
 32a:	8a e0       	ldi	r24, 0x0A	; 10
 32c:	90 e2       	ldi	r25, 0x20	; 32
 32e:	0e 94 db 00 	call	0x1b6	; 0x1b6 <SPI_MasterInit>
	
	/* PHASE 1: Transceive individual bytes. */

	/* MASTER: Pull SS line low. This has to be done since
	 *         SPI_MasterTransceiveByte() does not control the SS line(s). */
	SPI_MasterSSLow(ssPort, PIN4_bm);
 332:	1e 83       	std	Y+6, r17	; 0x06
 334:	c1 e0       	ldi	r28, 0x01	; 1
 336:	d0 e2       	ldi	r29, 0x20	; 32
 338:	05 e0       	ldi	r16, 0x05	; 5
 33a:	10 e2       	ldi	r17, 0x20	; 32
	for(uint8_t i = 0; i < NUM_BYTES; i++) {
		/* MASTER: Transmit data from master to slave. */
		SPI_MasterTransceiveByte(&spiMasterD, masterSendData[i]);

		/* SLAVE: Wait for data to be available. */
		while (SPI_SlaveDataAvailable(&spiSlaveD) == false) {
 33c:	0f 2e       	mov	r0, r31
 33e:	fb e1       	ldi	r31, 0x1B	; 27
 340:	ef 2e       	mov	r14, r31
 342:	f0 e2       	ldi	r31, 0x20	; 32
 344:	ff 2e       	mov	r15, r31
 346:	f0 2d       	mov	r31, r0
 348:	6e 01       	movw	r12, r28
	 *         SPI_MasterTransceiveByte() does not control the SS line(s). */
	SPI_MasterSSLow(ssPort, PIN4_bm);

	for(uint8_t i = 0; i < NUM_BYTES; i++) {
		/* MASTER: Transmit data from master to slave. */
		SPI_MasterTransceiveByte(&spiMasterD, masterSendData[i]);
 34a:	68 81       	ld	r22, Y
 34c:	8a e0       	ldi	r24, 0x0A	; 10
 34e:	90 e2       	ldi	r25, 0x20	; 32
 350:	0e 94 1a 01 	call	0x234	; 0x234 <SPI_MasterTransceiveByte>

		/* SLAVE: Wait for data to be available. */
		while (SPI_SlaveDataAvailable(&spiSlaveD) == false) {
 354:	d7 01       	movw	r26, r14
 356:	ed 91       	ld	r30, X+
 358:	fc 91       	ld	r31, X
 35a:	82 81       	ldd	r24, Z+2	; 0x02
 35c:	88 23       	and	r24, r24
 35e:	ec f7       	brge	.-6      	; 0x35a <main+0x50>

		}

		/* SLAVE: Get the byte received. */
		uint8_t slaveByte = SPI_SlaveReadByte(&spiSlaveD);
 360:	83 81       	ldd	r24, Z+3	; 0x03

		/* SLAVE: Increment received byte and send back. */
		slaveByte++;
 362:	8f 5f       	subi	r24, 0xFF	; 255
		SPI_SlaveWriteByte(&spiSlaveD, slaveByte);
 364:	83 83       	std	Z+3, r24	; 0x03

		/* MASTER: Transmit dummy data to shift data from slave to master. */
		uint8_t masterReceivedByte = SPI_MasterTransceiveByte(&spiMasterD, 0x00);
 366:	60 e0       	ldi	r22, 0x00	; 0
 368:	8a e0       	ldi	r24, 0x0A	; 10
 36a:	90 e2       	ldi	r25, 0x20	; 32
 36c:	0e 94 1a 01 	call	0x234	; 0x234 <SPI_MasterTransceiveByte>
 370:	21 96       	adiw	r28, 0x01	; 1

		/* MASTER: Check if the correct value was received. */
		if (masterReceivedByte != (masterSendData[i] + 1) ) {
 372:	28 2f       	mov	r18, r24
 374:	30 e0       	ldi	r19, 0x00	; 0
 376:	f6 01       	movw	r30, r12
 378:	80 81       	ld	r24, Z
 37a:	90 e0       	ldi	r25, 0x00	; 0
 37c:	01 96       	adiw	r24, 0x01	; 1
 37e:	28 17       	cp	r18, r24
 380:	39 07       	cpc	r19, r25
 382:	11 f0       	breq	.+4      	; 0x388 <main+0x7e>
			success = false;
 384:	10 92 00 20 	sts	0x2000, r1	; 0x802000 <__DATA_REGION_ORIGIN__>

	/* MASTER: Pull SS line low. This has to be done since
	 *         SPI_MasterTransceiveByte() does not control the SS line(s). */
	SPI_MasterSSLow(ssPort, PIN4_bm);

	for(uint8_t i = 0; i < NUM_BYTES; i++) {
 388:	c0 17       	cp	r28, r16
 38a:	d1 07       	cpc	r29, r17
 38c:	e9 f6       	brne	.-70     	; 0x348 <main+0x3e>
			success = false;
		}
	}

	/* MASTER: Release SS to slave. */
	SPI_MasterSSHigh(ssPort, PIN4_bm);
 38e:	80 e1       	ldi	r24, 0x10	; 16
 390:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>

	/* PHASE 2: Transceive data packet. */

	/* Create data packet (SS to slave by PD4). */
	SPI_MasterCreateDataPacket(&dataPacket,
 394:	68 94       	set
 396:	ee 24       	eor	r14, r14
 398:	e4 f8       	bld	r14, 4
 39a:	00 e6       	ldi	r16, 0x60	; 96
 39c:	16 e0       	ldi	r17, 0x06	; 6
 39e:	24 e0       	ldi	r18, 0x04	; 4
 3a0:	46 e0       	ldi	r20, 0x06	; 6
 3a2:	50 e2       	ldi	r21, 0x20	; 32
 3a4:	61 e0       	ldi	r22, 0x01	; 1
 3a6:	70 e2       	ldi	r23, 0x20	; 32
 3a8:	81 e1       	ldi	r24, 0x11	; 17
 3aa:	90 e2       	ldi	r25, 0x20	; 32
 3ac:	0e 94 08 01 	call	0x210	; 0x210 <SPI_MasterCreateDataPacket>
	                           NUM_BYTES,
	                           &PORTD,
	                           PIN4_bm);

	/* Transceive packet. */
	SPI_MasterTransceivePacket(&spiMasterD, &dataPacket);
 3b0:	61 e1       	ldi	r22, 0x11	; 17
 3b2:	70 e2       	ldi	r23, 0x20	; 32
 3b4:	8a e0       	ldi	r24, 0x0A	; 10
 3b6:	90 e2       	ldi	r25, 0x20	; 32
 3b8:	0e 94 26 01 	call	0x24c	; 0x24c <SPI_MasterTransceivePacket>
			success = false;
		}
	}

	while(true) {
		nop();
 3bc:	00 00       	nop
 3be:	fe cf       	rjmp	.-4      	; 0x3bc <main+0xb2>

000003c0 <_exit>:
 3c0:	f8 94       	cli

000003c2 <__stop_program>:
 3c2:	ff cf       	rjmp	.-2      	; 0x3c2 <__stop_program>
